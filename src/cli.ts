import { BinanceClient, BybitClient, OKXClient, DYDXClient, HyperliquidClient } from './exchanges/index.js';
import { PrismMonitor } from './monitor/index.js';
import type { CascadeRisk } from './predictor/index.js';
import type { AggregatedData } from './aggregator/index.js';
import { logger as rootLogger } from './lib/logger.js';

const log = rootLogger.child({ component: 'cli' });

const SYMBOLS = ['BTC', 'ETH'];
const POLL_INTERVAL_MS = 30_000; // 30 seconds

function clearScreen(): void {
  process.stdout.write('\x1B[2J\x1B[0f');
}

function formatUSD(value: number): string {
  if (value >= 1_000_000_000) return `$${(value / 1_000_000_000).toFixed(2)}B`;
  if (value >= 1_000_000) return `$${(value / 1_000_000).toFixed(2)}M`;
  if (value >= 1_000) return `$${(value / 1_000).toFixed(1)}K`;
  return `$${value.toFixed(0)}`;
}

function formatFundingRate(rate: number): string {
  const pct = (rate * 100).toFixed(4);
  return rate >= 0 ? `+${pct}%` : `${pct}%`;
}

function getRiskIcon(level: CascadeRisk['riskLevel']): string {
  switch (level) {
    case 'critical': return 'ðŸ”´';
    case 'high': return 'ðŸŸ ';
    case 'elevated': return 'ðŸŸ¡';
    case 'moderate': return 'ðŸ”µ';
    case 'low': return 'ðŸŸ¢';
  }
}

function getRiskBar(score: number): string {
  const filled = Math.round(score / 10);
  const empty = 10 - filled;
  return 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(empty);
}

function renderData(data: AggregatedData, cascadeRisks: CascadeRisk[], dbStats?: { snapshotCount: number }): void {
  clearScreen();

  const w = (s: string) => process.stdout.write(s + '\n');
  w('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  w('â•‘              PRISM - Cross-Exchange Risk Intelligence                â•‘');
  w('â•‘                    Liquidation Cascade Predictor                     â•‘');
  w('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  w('');
  w(`  Exchanges: ${data.exchanges.join(', ')}`);
  w(`  Updated:   ${new Date(data.timestamp).toLocaleTimeString()}`);
  if (dbStats) {
    w(`  DB Records: ${dbStats.snapshotCount.toLocaleString()}`);
  }
  w('');

  for (const symbol of data.symbols) {
    const m = data.metrics[symbol];
    const risk = cascadeRisks.find(r => r.symbol === symbol);
    if (!m || !risk) continue;

    // Header with risk level
    w('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
    w(`â”‚  ${symbol}/USDT  ${getRiskIcon(risk.riskLevel)} Risk: ${risk.riskScore}/100 [${getRiskBar(risk.riskScore)}] ${risk.riskLevel.toUpperCase().padStart(10)}  â”‚`);
    w('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤');

    // Market data
    w(`â”‚  Price: $${m.avgMarkPrice.toLocaleString(undefined, { maximumFractionDigits: 2 }).padEnd(12)} OI: ${formatUSD(m.totalOpenInterestValue).padEnd(10)} Funding: ${formatFundingRate(m.avgFundingRate).padEnd(10)}â”‚`);
    w('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤');

    // Risk factors
    w('â”‚  Risk Factors:                                                       â”‚');
    for (const factor of risk.factors) {
      const scoreBar = 'â–“'.repeat(Math.round(factor.score / 20)) + 'â–‘'.repeat(5 - Math.round(factor.score / 20));
      const line = `â”‚    ${factor.name.padEnd(20)} [${scoreBar}] ${factor.score.toFixed(0).padStart(3)}/100`;
      w(line.padEnd(72) + 'â”‚');
    }

    // Prediction if elevated risk
    if (risk.prediction) {
      w('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤');
      w('â”‚  âš ï¸  CASCADE PREDICTION:                                             â”‚');
      const pred = risk.prediction;
      const direction = pred.direction === 'long_squeeze' ? 'ðŸ“‰ LONG SQUEEZE' : 'ðŸ“ˆ SHORT SQUEEZE';
      w(`â”‚    Direction:    ${direction.padEnd(52)}â”‚`);
      w(`â”‚    Probability:  ${(pred.probability * 100).toFixed(0)}%`.padEnd(72) + 'â”‚');
      w(`â”‚    Est. Impact:  ${formatUSD(pred.estimatedImpact)} in liquidations`.padEnd(72) + 'â”‚');
      w(`â”‚    Trigger:      $${pred.triggerPrice.toLocaleString(undefined, { maximumFractionDigits: 2 })} (${pred.triggerDistance.toFixed(1)}% away)`.padEnd(72) + 'â”‚');
      w(`â”‚    Time Window:  ${pred.timeWindow}`.padEnd(72) + 'â”‚');
    }

    w('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');
    w('');
  }

  // Alert summary
  const criticalRisks = cascadeRisks.filter(r => r.riskLevel === 'critical' || r.riskLevel === 'high');
  if (criticalRisks.length > 0) {
    w('âš ï¸  HIGH RISK ASSETS: ' + criticalRisks.map(r => `${r.symbol} (${r.riskScore})`).join(', '));
  } else {
    w('âœ… All assets within normal risk parameters');
  }

  w('');
  w('  Press Ctrl+C to stop');
}

async function main(): Promise<void> {
  const clients = [
    new BinanceClient(),
    new BybitClient(),
    new OKXClient(),
    new DYDXClient(),
    new HyperliquidClient(),
  ];

  const monitor = new PrismMonitor(clients, {
    symbols: SYMBOLS,
    intervalMs: POLL_INTERVAL_MS,
    persistData: true, // Enable database persistence
  });

  monitor.on('cascade', async (risks: CascadeRisk[]) => {
    const data = monitor.getLastData();
    if (!data) return;

    const db = monitor.getDatabase();
    const dbStats = db ? await db.getStats() : undefined;
    renderData(data, risks, dbStats);
  });

  monitor.on('error', (error: Error) => {
    log.error({ err: error.message }, 'Monitor error');
  });

  // Handle graceful shutdown
  process.on('SIGINT', async () => {
    log.info('Shutting down');
    await monitor.stop();
    process.exit(0);
  });

  log.info('Starting Prism monitor with cascade prediction');
  log.info('Data will be persisted to PostgreSQL');
  await monitor.start();
}

main().catch((err) => log.error({ err: err instanceof Error ? err.message : err }, 'Fatal error'));
